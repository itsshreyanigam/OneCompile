var exec = require('child_process').exec;
var fs = require('fs');
var cuid = require('cuid');
var colors = require('colors');
var cppModule = require('./cppModule.js');
var javaModule = require('./javaModule.js');
var pyModule = require('./pyModule.js');
var csModule = require('./csModule.js');
var vbModule = require('./vbModule.js');
const path = require('path');



exports.stats = false;

exports.init = function (option) {
	if (option) {
		if (option.stats === true) {
			console.log('Statistics for compilex is On'.green);
			exports.stats = true;
		}
	}
	fs.exists('./temp', function (exists) {
		if (!exists) {
			if (exports.stats) {
				console.log('INFO: '.cyan + 'temp directory created for storing temporary files.'.cyan)
			}
			fs.mkdirSync('./temp');
		}
	});
}
function generateUniqueId() {
    return Math.random().toString(36).substr(2, 9);
}

function ensureTempDirectoryExists() {
    const tempDir = path.join(__dirname, 'temp');
    if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir);
    }
}
function extractClassName(code) {
    const classNameMatch = code.match(/class\s+(\w+)/);
    return classNameMatch ? classNameMatch[1] : null;
}
function compileAndRun(command, runCommand, callback, input = null, tempFiles = []) {
    exec(command, (error, stdout, stderr) => {
        console.log(`Compile Command: ${command}`);
        if (error) {
            console.error(`Error during compilation: ${stderr}`);
            callback({ error: `Error during compilation: ${stderr}` });
        } else {
            if (input) {
                const inputFilename = path.join(__dirname, 'temp', `${generateUniqueId()}.txt`);
                fs.writeFile(inputFilename, input, (err) => {
                    if (err) {
                        console.error(`Error writing input file: ${err}`);
                        callback({ error: `Error writing input file: ${err}` });
                    } else {
                        tempFiles.push(inputFilename);
                        exec(`${runCommand} < ${inputFilename}`, (runError, runStdout, runStderr) => {
                            console.log(`Run Command with input: ${runCommand} < ${inputFilename}`);
                            cleanupFiles(tempFiles);
                            if (runError) {
                                console.error(`Error during execution with input: ${runStderr}`);
                                callback({ error: `Error during execution with input: ${runStderr}` });
                            } else {
                                callback({ output: runStdout });
                            }
                        });
                    }
                });
            } else {
                exec(runCommand, (runError, runStdout, runStderr) => {
                    console.log(`Run Command: ${runCommand}`);
                    cleanupFiles(tempFiles);
                    if (runError) {
                        console.error(`Error during execution: ${runStderr}`);
                        callback({ error: `Error during execution: ${runStderr}` });
                    } else {
                        callback({ output: runStdout });
                    }
                });
            }
        }
    });
}

function cleanupFiles(files) {
    files.forEach((file) => {
        fs.unlink(file, (err) => {
            if (err) {
                console.error(`Error deleting file ${file}: ${err}`);
            } else {
                console.log(`Deleted file: ${file}`);
            }
        });
    });
}



exports.compileCPP = function (envData, code, callback) {
    ensureTempDirectoryExists();
    const filename = path.join(__dirname, 'temp', `${generateUniqueId()}.cpp`);
    const outputFilename = `${filename}.out`;

    fs.writeFile(filename, code, (err) => {
        if (err) {
            console.error(`Error writing file: ${err}`);
            callback({ error: `Error writing file: ${err}` });
        } else {
            const command = `${envData.cmd} ${filename} -o ${outputFilename}`;
            compileAndRun(command, outputFilename, callback);
        }
    });
};

exports.compileCPPWithInput = function (envData, code, input, callback) {
    ensureTempDirectoryExists();
    const filename = path.join(__dirname, 'temp', `${generateUniqueId()}.cpp`);
    const outputFilename = `${filename}.out`;

    fs.writeFile(filename, code, (err) => {
        if (err) {
            console.error(`Error writing file: ${err}`);
            callback({ error: `Error writing file: ${err}` });
        } else {
            const command = `${envData.cmd} ${filename} -o ${outputFilename}`;
            compileAndRun(command, outputFilename, callback, input);
        }
    });
};

exports.compileJava = function (envData, code, callback) {
    ensureTempDirectoryExists();
    const className = extractClassName(code);
    if (!className) {
        callback({ error: "Error: Unable to find class name in the Java code." });
        return;
    }
    const filename = path.join(__dirname, 'temp', `${className}.java`);

    fs.writeFile(filename, code, (err) => {
        if (err) {
            console.error(`Error writing file: ${err}`);
            callback({ error: `Error writing file: ${err}` });
        } else {
            const command = `javac ${filename}`;
            const runCommand = `java -cp ${path.join(__dirname, 'temp')} ${className}`;
            console.log(`Compiling with command: ${command}`);
            console.log(`Running with command: ${runCommand}`);
            compileAndRun(command, runCommand, callback);
        }
    });
};

exports.compileJavaWithInput = function (envData, code, input, callback) {
    ensureTempDirectoryExists();
    const className = extractClassName(code);
    if (!className) {
        callback({ error: "Error: Unable to find class name in the Java code." });
        return;
    }
    const filename = path.join(__dirname, 'temp', `${className}.java`);

    fs.writeFile(filename, code, (err) => {
        if (err) {
            console.error(`Error writing file: ${err}`);
            callback({ error: `Error writing file: ${err}` });
        } else {
            const command = `javac ${filename}`;
            const runCommand = `java -cp ${path.join(__dirname, 'temp')} ${className}`;
            console.log(`Compiling with command: ${command}`);
            console.log(`Running with command: ${runCommand}`);
            compileAndRun(command, runCommand, callback, input);
        }
    });
};

exports.compilePython = function (envData, code, callback) {
    ensureTempDirectoryExists();
    const filename = path.join(__dirname, 'temp', `${generateUniqueId()}.py`);

    fs.writeFile(filename, code, (err) => {
        if (err) {
            console.error(`Error writing file: ${err}`);
            callback({ error: `Error writing file: ${err}` });
        } else {
            const command = `python ${filename}`;
            compileAndRun(command, command, callback);
        }
    });
};

exports.compilePythonWithInput = function (envData, code, input, callback) {
    ensureTempDirectoryExists();
    const filename = path.join(__dirname, 'temp', `${generateUniqueId()}.py`);
    const inputFilename = path.join(__dirname, 'temp', `${generateUniqueId()}.txt`);

    fs.writeFile(filename, code, (err) => {
        if (err) {
            console.error(`Error writing Python file: ${err}`);
            callback({ error: `Error writing Python file: ${err}` });
        } else {
            fs.writeFile(inputFilename, input, (err) => {
                if (err) {
                    console.error(`Error writing input file: ${err}`);
                    callback({ error: `Error writing input file: ${err}` });
                } else {
                    const command = `python ${filename}`;
                    const runCommand = `python ${filename} < ${inputFilename}`;
                    console.log(`Running Python command with input: ${runCommand}`);

                    exec(runCommand, (runError, runStdout, runStderr) => {
                        if (runError) {
                            console.error(`Error during execution with input: ${runStderr}`);
                            callback({ error: `Error during execution with input: ${runStderr}` });
                        } else {
                            callback({ output: runStdout });
                        }
                    });
                }
            });
        }
    });
};

exports.compileCS = function (envData, code, fn) {
	if (exports.stats)
		csModule.stats = true;
	csModule.compileCS(envData, code, fn);
}

exports.compileCSWithInput = function (envData, code, input, fn) {
	if (exports.stats)
		csModule.stats = true;
	csModule.compileCSWithInput(envData, code, input, fn);
}

exports.compileVB = function (envData, code, fn) {
	if (exports.stats)
		vbModule.stats = true;
	vbModule.compileVB(envData, code, fn);
}

exports.compileVBWithInput = function (envData, code, input, fn) {
	if (exports.stats)
		vbModule.stats = true;
	vbModule.compileVBWithInput(envData, code, input, fn);
}

exports.flushSync = function () {
	path = '	./temp/';
	fs.readdir(path, function (err, files) {
		if (!err) {
			for (var i = 0; i < files.length; i++) {

				fs.unlinkSync(path + files[i]);

			}
		}
	});
}

exports.flush = function (fn) {
	var path = './temp/';
	fs.readdir(path, function (err, files) {
		if (err) {
			console.error("Error reading directory: " + err);
			fn(err);
		} else {
			files.forEach(function (file) {
				var filePath = path + file;
				fs.stat(filePath, function (err, stats) {
					if (err) {
						console.error("Error checking file stats for " + filePath + ": " + err);
					} else {
						if (stats.isFile()) {
							// It's a file, so unlink it
							fs.unlink(filePath, function (err) {
								if (err) {
									console.error("Error deleting file " + filePath + ": " + err);
								}
							});
						} else if (stats.isDirectory()) {
							// It's a directory, so use rmdir to remove it
							fs.rmdir(filePath, { recursive: true }, function (err) {
								if (err) {
									console.error("Error deleting directory " + filePath + ": " + err);
								}
							});
						}
					}
				});
			});
			fn();
		}
	});
};


exports.fullStat = function (fn) {
	var uptime = process.uptime();


	var cppCount = 0;
	var javaCount = 0;
	var pyCount = 0;
	var total = 0;

	var files = fs.readdirSync('temp');
	for (var file in files) {
		var stat = fs.statSync('temp/' + files[file]);
		if (stat.isFile()) {
			if (files[file].indexOf('.cpp') !== -1) {
				cppCount++;
			}
			if (files[file].indexOf('.py') !== -1) {
				pyCount++;
			}
		}
		else {
			javaCount++;
		}
	}

	var jsonData = {
		serverUptime: uptime,
		fileDetails: {
			cpp: cppCount,
			java: javaCount,
			python: pyCount
		}
	}
	if (exports.stats) {

		var str = "Server Statistics".yellow + "\n"
			+ "compilex Server Uptime : " + uptime + "\n"
			+ "Files on storage :" + "\n"
			+ "C & CPP files : " + cppCount + "\n"
			+ "Java files : " + javaCount + "\n"
			+ "Python files : " + pyCount;
		console.log(str);
	}
	fn(jsonData);

}
